##########################################################################
#
# SALT - [S]teadfasterX [A]ll-in-one [L]G [T]ool
#
# Copyright (C): 2017, steadfasterX <steadfastX|boun.cr>
#
# global functions for SALT
#
# include this with:
# source salt.func
#
##########################################################################
VARS="${0%/*}/salt.vars"

source $VARS 
[ $? -ne 0 ]&& echo "ERROR: including $VARS" && exit 3

######################################################################################

# there is no need to change these as they get auto set by the VERSION var
if [ "${VERSION/*:}" == "TESTING" ];then
    export BRSALT=develop
    export BRKDZ=develop
    export BRLAF=g4-develop
    export BROSALT=master
    export BROKDZ=master
    export BROLAF=g4-stable
else
    export BRSALT=master
    export BRKDZ=master
    export BRLAF=g4-stable
    export BROSALT=develop
    export BROKDZ=develop
    export BROLAF=g4-develop
fi

######################################################################################


# do not echo but write log entry
F_LOG(){
    # takes 1 argument
    # 1 => Message to log/echo (can handle \t and \n)
  
    echo -e "$(date '+%F %T'): $1" >> $LOG
}; export -f F_LOG

# echo output and save it in a log as well
F_ELOG(){
  # takes 1 argument
  # 1 => Message to log/echo (can handle \t and \n)
  
  echo -e "$(date '+%F %T'): $1" | tee -a $LOG

}; export -f F_ELOG

# print a message
F_MSG(){ F_LOG "$FUNCNAME: started"
    # takes 2 arguments
    #   
    #  1 => box width
    #  2 => message to show
    # optional:
    #  3 => free args
    $FYAD --width=$1 --title="$YTITLE" --text "$2" $3
    RET=$?
    F_LOG "$FUNCNAME: ended"
    echo $RET
}; export -f F_MSG

# print an error message
F_MSGE(){ F_LOG "$FUNCNAME: started"
    # takes up to 3 arguments
    #
    # 1 => width
    # 2 => message
    #
    # optional:
    # 3 => yad stuff
    
    $FYAD --width="$1" --title="$YTITLE - ERROR" --image="$SICONS/error.png" --text "ERROR:\n\n$2" $3 --button=Exit:0
    RES=$?
    F_LOG $RES
    echo $RES
}; export -f F_MSGE

# print an OK message
F_MSGOK(){ F_LOG "$FUNCNAME: started"
    # takes up to 3 arguments
    #
    # 1 => width
    # 2 => message
    #
    # optional:
    # 3 => yad stuff

    $FYAD --width="$1" --title="$YTITLE - SUCCESS" --image="$SICONS/ok_64x64.png" --text "\n$2" $3 --button=Close:0
    RES=$?
    F_LOG $RES
    echo $RES
}; export -f F_MSGOK

# check errorcode + exit when not errorcode not as expected
F_ERR(){ F_LOG "$FUNCNAME: started"
  # takes 2-4 arguments
  #
  # mandantory:
  #   1 => the process initiating this function
  #   2 => the errorcode (usually $? in your call)
  # optional (4 requires at least an empty 3):
  #   3 => the message to show
  #   4 => the expected error code (if missing we expect 0)
  CALLER=$1
  ERRCODE=$2
  MSG="$3"
  EXPECTED=$4

  [ -z "$EXPECTED" ] && EXPECTED=0
  
  if [ -z "$CALLER" ]||[ -z "$ERRCODE" ];then
    F_ELOG "Required argument missing in $FUNCNAME!"
    F_EXIT $FUNCNAME 3
  fi
  if [ "$ERRCODE" != "$EXPECTED" ];then
    F_ELOG "ERROR: $ERRCODE occurred in $CALLER (expected $EXPECTED, got $ERRCODE)"
    [ ! -z "$MSG" ] && F_MSGE 400 "$MSG"
    F_EXIT "${CALLER}->${FUNCNAME}" 4
  else
    echo "OK: $CALLER"
  fi
}; export -f F_ERR

# exit properly
F_EXIT(){ F_LOG "$FUNCNAME: started"
  # takes 2 arguments (mandantory)
  # 1 => the function or reason who calls the exit function
  # 2 => the exitcode to be used
  EREASON=$1
  ECODE=$2
  
  F_ELOG "EXIT: $EREASON with code $ECODE"
  
  # TODO (optional): do any other actions
  exit $ECODE
  F_LOG "$FUNCNAME: ended"
}; export -f F_EXIT

# get current phone data
F_GETINFO(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    (F_AUTH 2>&1) >> $LOG
    IARB=$(F_CDARB)
    echo "arb:${IARB}" \
    && python2 $LAFPATH/lglaf.py -c '!INFO GPRO \x08\x0b\0\0' \
       | python2 $LAFPATH/scripts/parse-props.py - \
       | egrep "(device_sw_version|model_name|secure_device|laf_sw_version|device_factory_version|target_country|battery_level)" | tr "\n" " " | tr -d "'" | tee -a $LOG
    F_LOG "$FUNCNAME: ended"
}; export -f F_GETINFO

# extract a KDZ
F_EXTRACTKDZ(){ F_LOG "$FUNCNAME: started"
    # takes XXXX arguments
    #
    #   1 => KDZ file name (full path)
    #   2 => Target directory
    #   3 => extract userdata
    #   4 => extract cache
    LGKDZ="$1"
    LGTARGET="$2"
    [ "$3" == "TRUE" ] && EARGS="--with-userdata"
    [ "$4" == "TRUE" ] && EARGS="$EARGS --with-cache"

    [ -z "$LGKDZ" -o ! -f "$LGKDZ" ] && F_ERR $FUNCNAME 3 "Internal error: empty LGKDZ or file not found"
    [ -z "$LGTARGET" -o ! -d "$LGTARGET" ] && F_ERR $FUNCNAME 3 "Internal error: empty LGTARGET or directory not found"

    ($KDZMGR --batch -x $LGKDZ -d $LGTARGET $EARGS 2>&1) | tee -a $LOG | $FYAD --title="$YTITLE - EXTRACT" --text-info --text "\n  <b><span color='#ff0000'>BE PATIENT! THE SCREEN REFRESHES EVERY MINUTE FIRST!\n  WAIT until you see the message: All done</span></b>\n" --listen --tail --height=600 --width=800 --wrap --fore=blue --button="Continue (wait until you see ALL DONE)":0
    EXERR=$?
    [ $EXERR -ne 0 ] && F_ERR $FUNCNAME $EXERR "ERROR occured or aborted by user!"
    F_LOG "$FUNCNAME: ended"
}; export -f F_EXTRACTKDZ

# check device for for antirollback bullshit (I'm still pissed off how a vendor is doing this! I mean HARDBRICK a phone ?? wtf LG?)
F_CDARB(){ F_LOG "$FUNCNAME: started"
    # takes no arguments
    #
    DEVARBEMPTY=0
    DEVARB=$(python2 $LAFPATH/partitions.py --skip-hello --dump - sbl1 | strings | grep "0 SW_ID" |cut -d " " -f 2 |tr -d "0" | $FYAD --title="$YTITLE - COLLECTING" --text "\n  Collecting device information..." --width=400 --progress --pulsate --auto-close --button=Abort)
    [ -z "$DEVARB" ] && DEVARB="0" && DEVARBEMPTY=1
    F_LOG "$FUNCNAME: DEVARB=$DEVARB, DEVARBEMPTY=$DEVARBEMPTY"
    echo "${DEVARB}:${DEVARBEMPTY}"
    F_LOG "$FUNCNAME: ended"
}; export -f F_CDARB

# check local file for antirollback bullshit (I'm still pissed off how a vendor is doing this! I mean HARDBRICK a phone ?? wtf LG?)
F_CKARB(){ F_LOG "$FUNCNAME: started"
    # takes 1 argument
    #  
    # 1 => path to the sbl1 file to check

    KDZDIR=$1
    ARBFILE="$KDZDIR/sbl1.image"

    [ ! -f "$ARBFILE" ] && F_ERR $FUNCNAME 3 "\n  ERROR!\n\nMissing required file to check for ARB\n  (checked for: $ARBFILE)!"

    KDZARB=$(strings "$ARBFILE" | grep "0 SW_ID" |cut -d " " -f 2 |tr -d "0")
    [ -z "$KDZARB" ] && KDZARB=0
    F_LOG "KDZARB=$KDZARB"
    echo $KDZARB
    F_LOG "$FUNCNAME: ended"
}; export -f F_CKARB

# check device model
F_CHKMODEL(){ F_LOG "$FUNCNAME: started"
    # takes 1 argument
    #
    # 1 => KDZFILE to compare

    KFILE="$1"
    [ -z "$KFILE" -o ! -f "$KFILE" ] && F_ERR $FUNCNAME 3 "\n  ERROR!\n\n  KFILE missing for compare!"

    DEVINF=$(F_GETINFO)
    for i in $DEVINF;do
        case ${i/:*/} in
           model_name) LGMODEL=${i/*:/};;
        esac
    done
    KDZMODEL=$(dd if=$KFILE bs=512 count=10000 2>&1| strings | egrep -m1 'LG-[L|H|V]')
    if [ -z "$KDZMODEL" ] ;then
        RES="${LGMODEL}:unknown"
    else
        RES="${LGMODEL}:${KDZMODEL}"
    fi
    F_LOG "$FUNCNAME: $RES"
    echo $RES
    F_LOG "$FUNCNAME: ended"
} ; export -f F_CHKMODEL

# flash a KDZ
F_FLASHKDZ(){ F_LOG "$FUNCNAME: started"
    # takes 5 arguments
    #
    #   1 => KDZ filename
    #   2 => Factory reset
    #   3 => Model check
    #   4 => ARB check
    #   5 => test mode

    LGKDZ="$1"
    LGFR="$2"
    LGCHKMOD="$3"
    LGARB="$4"
    LGDRY="$5"

    # autoextract kdz without userdata and cache
    KDZTMP=/tmp
    F_EXTRACTKDZ $LGKDZ $KDZTMP FALSE FALSE

    # test mode?
    if [ "$LGDRY" != "FALSE" ];then
        ($KDZMGR --batch --flash $KDZTMP/extracteddz --test 2>&1) | tee -a $LOG | $FYAD --title="$YTITLE - FLASH" --text-info --text "\n  <b><span color='#009900'>FLASHING KDZ (TEST)...</span></b>\n" --listen --tail --height=600 --width=900 --wrap --fore=blue --button="Next":0
        $FYAD --title="$YTITLE - FLASH" --text "\n  TEST run finished\n\n  Do you want to continue to FLASH in REAL now?" --button=FLASH:1 --button=Cancel:0
        [ $? -ne 1 ] && echo canceling.. && F_EXIT $FUNCNAME $?
    fi

    # check device connection
    F_CHKDEVCON
   
    # recheck valid image files
    # TODO

    # check device model
    CHKMRES=$(F_CHKMODEL "$LGKDZ")
    
    # check ARB
    ARBOK=0
    KARB=$(F_CKARB $KDZTMP/extracteddz)
    DARB=$(F_CDARB)
    F_ELOG "KARB: $KARB, DARB: $DARB"
    # verify the internal functions do not generate crap
    [ -z "$KARB" -o -z "$DARB" ] && F_ERR $FUNCNAME 3 "\n  ERROR!\n\n  Device ARB or KDZ ARB cannot be checked! ABORTED!!"
    # verify ARB compat
    [ "${DARB/:*}" -qe 0 ] && [ "$KARB" -ge "${DARB/:*}" ] && F_ELOG "Device and KDZ ARB are compatible" && ARBOK=1
    # a bulletproof method to avoid issues with any of the above (e.g. when KARB or DARB are not digits etc)
    [ "$ARBOK" -ne 1 ] && F_ERR $FUNCNAME 3 "\n  ERROR!\n\n  ARB is NOT compatible with your device! ABORTED!"

    # manual verification by the user
    if [ -z "${CHKMRES/*:}" ] || [ -z "${CHKMRES/:*}" ]|| [ "${CHKMRES/:*}" == "unknown" ] || [ "${CHKMRES/*:}" != "${CHKMRES/:*}" ];then
        FYAD --title="$YTITLE - CHECKUP" --text "\n  WARNING: <b><span color='#ff0000'>KDZ file and device information does not match!</span></b>\n  Device model:\t${CHKMRES/*:}\n  KDZ is for:\t\t${CHKMRES/:*}\n\n  ARB of your device <b>seems</b> to be compatible with the KDZ file\n  Device:\t$DARB\n  KDZ:\t$KARB\n\n  You can doublecheck <a href='http://tinyurl.com/antirollg4'>here</a>\n\n  Do you really want to continue and so FLASH now?" --button="Flash (may HARD BRICK)":0 --button=Cancel:1
    else
        $FYAD --title="$YTITLE - CHECKUP" --text "\n  KDZ <b>file and device</b> information match\n  Device model:\t${CHKMRES/*:}\n  KDZ is for:\t\t${CHKMRES/:*}\n\n  ARB of your device <b>seems</b> to be compatible with the KDZ file\n  Device:\t$DARB\n  KDZ:\t$KARB\n  You can doublecheck ARB <a href='http://tinyurl.com/antirollg4'>here</a>\n\n  Do you really want to continue and so FLASH now?" --button="Flash (on your own risk)":0 --button=Cancel:1
    fi
    # abort when needed
    [ $? -ne 0 ] && F_ERR $FUNCNAME 3 "\n  Aborted on user check verification"

    # If all the above is fine: FLASH
    F_FLASHPART "$KDZTMP/extracteddz"

    # factory reset to avoid bootloop
    # TODO: accept the taken user choice 
    F_WIPEPART userdata ni

    F_MSG 400 "KDZ flashing completed. check the log for details (SALT main screen)"
    F_LOG "$FUNCNAME: ended"
}; export -f F_FLASHKDZ

# choose and flash partitions from a backup or extracted KDZ
F_FLASHPART(){ F_LOG "$FUNCNAME: started"
    # takes 1 optional argument
    #
    # 1 => image files path

    if [ -z "$1" ];then
        AIMGDIR=$($FYAD --width=600 --title="$YTITLE - FOLDER" --form \
                    --field="  Select the source folder":DIR \
                  $HOME)
        IMGDIR=$(echo $AIMGDIR|cut -d '|' -f1)
    else
        IMGDIR="$1"
    fi

    F_LOG "$FUNCNAME: IMGDIR=$IMGDIR"

    [ ! -d "$IMGDIR" ] && F_ERR $FUNCNAME 3 "\n  ERROR!\n\n Folder \n\n  $IMGDIR\n\n  does not exists?!"
    
    # create a list of *.image files and let the user choose
    IMGFILES=$(for ifile in $(find "$IMGDIR" -maxdepth 1 -type f -name *.bin -or -name *.img -or -name *.image | tr " " "_" |grep -vi GPT);do echo "${ifile##*/}";done | tr "\n" " ")

    F_ELOG "($FUNCNAME) image files: $IMGFILES"

    # give proper default choice for what to flash and what not
    unset IRES
    for f in $IMGFILES;do
        AVIMG="${f/:*}"
        APART=$(echo "${f/*:}" | sed -e 's/\.image//g;s/\.img//g;s/\.bin//g;s/mmcblk0p\(.*\)/\1/g')
        case $APART in
            grow|cache|userdata|modemst1|modemst2|persist|persistent|drm)
              if [ -z "$IRES" ];then IRES="false\n${AVIMG}\n${APART}\nunneeded\n99"; else IRES="$IRES false\n${AVIMG}\n${APART}\nunneeded\n99" ;fi
            ;;
            rpm|rpmbak|tz|tzbak|sdi|sdibak|aboot|abootbak|pmic|pmicbak|hyp|hypbak|sbl1|sbl1bak|laf)
              if [ -z "$IRES" ];then IRES="true\n${AVIMG}\n${APART}\nbootloader\n1"; else IRES="$IRES true\n${AVIMG}\n${APART}\nbootloader\n1" ;fi
            ;;
            misc|devinfo)
              if [ -z "$IRES" ];then 
                IRES="false\n${AVIMG}\n${APART}</span>\n<span\tcolor='#ff0000'>dangerous</span>\n88"
              else 
                IRES="$IRES false\n${AVIMG}\n${APART}\n<span\tcolor='#ff0000'>dangerous</span>\n88"
              fi
            ;;
            modem|limits|mpt|apdp|msadp|dpo|fsg|fsc|ssd|keystore|DDR|sec|encrypt|eksst|rct|boot|recovery|sns|eri|raw_resources*|operatorlogging|carrier|cust|felicia|factory|fota|system)
            if [ -z "$IRES" ];then
                IRES="true\n${AVIMG}\n${APART}\n<span\tcolor='#558000'>safe-to-flash</span>\n2"
            else
                IRES="$IRES true\n${AVIMG}\n${APART}\n<span\tcolor='#558000'>safe-to-flash</span>\n2"
            fi
            ;;
            *)
            if [ -z "$IRES" ];then
                IRES="true\n${AVIMG}\n${APART}\nunknown-type\n2"
            else
                IRES="$IRES true\n${AVIMG}\n${APART}\nunknown-type\n2"
            fi
            ;;
        esac
    done

    F_ELOG "($FUNCNAME) created yad list: $IRES"

    CHOOSENP=$(for files in $IRES;do echo -e "$files" ;done \
                | $FYAD --height=800 --width=600 --title="$YTITLE - FOLDER" --text "\n  Select the partitions you want to flash\n  (the RECOMMENDED partitions to flash are CHECKED already!)\n" --list --checklist \
                        --column="Flash":CHK --column="Image File":TXT --column="Target partition" --column="Type" --column=sort_int --hide-column=5  --listen --no-selection \
                        --button=FLASH:0 --button=Abort:99 |cut -d "|" -f 2-3,5 | tr "|" ":" )
    CERR=$?
    [ $CERR -ne 0 ] && F_ERR $FUNCNAME 0 "No partition?"
    F_LOG "CERR: $CERR"

    CHCOUNT=$(echo "$CHOOSENP" |tr " " "\n" |grep -c :)
    [ $CHCOUNT -lt 1 ] && F_ERR $FUNCNAME 0 "No partition selected?"

    F_ELOG "choosen partitions: $CHOOSENP -> $CHCOUNT"

    SORTEDP=$(echo "$CHOOSENP" |tr " " "\n" | sort -t : -k 3n | cut -d ":" -f 1-2 | tr "\n" " " )
    CHCOUNT=$(echo "$SORTEDP" |tr " " "\n" |grep -c :)

    F_ELOG "sorted partitions: $SORTEDP -> $CHCOUNT"

    # FLASH
    F_AUTH
    CNT=0
    for img in $SORTEDP; do
        CNT=$((CNT+1))
        FFILE="$IMGDIR/${img/:*}"
        FPART=${img/*:}
        F_LOG "flashing: $FFILE to $FPART"

	# inform yad which partition we flash
	echo "#flashing: $FPART"

        F_LOG "$FUNCNAME: $FPART starting"
        python2 -u $LAFPATH/partitions.py --batch --restore "$FFILE" $FPART 2>&1 | sed -u -e "s%:\([0-9]*\):\([0-9]*\)%,#$FPART: \1 KB / \2 KB%g;s/,/\n/g"
	FLASHERR=$?
	if [ $FLASHERR -eq 0 ];then
		echo "100"
                F_LOG "$FUNCNAME: $FPART finished"
                [ $CNT -eq $CHCOUNT ] && echo '# ALL PARTITIONS FLASHED SUCCESSFULLY' && F_LOG "$FUNCNAME: All partitions flashed successfully"
	else
                F_LOG "$FUNCNAME: $FPART FAILED with $FLASHERR"
		echo "# $FPART: FAILED"
	        F_ERR $FUNCNAME 4 "\n  ERROR!\n\n  DO NOT REBOOT YOUR DEVICE!\n  FLASHING PROBLEM OCCURED!!!\n  while flashing:\n\n  <b>$FPART</b>" 
	fi
    done | $FYAD --title="$YTITLE - FLASHING" --text="\n  <b>SALT is now flashing...</b>\n  (if the progress bar does NOT get up to 100%: DO NOT REBOOT THE DEVICE!)\n\n" --width 900 --progress --button='Close (WAIT until all is flashed)':1
    FLERR=${PIPESTATUS[0]}

    # check result
    if [ "$FLERR" -eq 0 ];then
        F_MSGOK 400 "Flashing was successful!"
    else
        F_MSGE 400 "FLASHING ENDED WITH ERROR: $FLERR\n\nCheck Debug Log in SALT main screen!\nDO NOT REBOOT THE DEVICE TO AVOID HARD BRICK!!!!"
    fi

    # wipe cache
    F_WIPEPART cache ni || F_MSGE 400 "Wiping cache ended with an error: $WIPERR\n\nCheck Debug Log in SALT main screen."
    
    # sync filesystems
    F_SYNC || F_MSGE 400 "Syncing filesystems ended with an error: $WIPERR\n\nCheck Debug Log in SALT main screen.\nDO NOT REBOOT THE DEVICE!"
    F_LOG "$FUNCNAME: ended"
}; export -f F_FLASHPART

# authenticate device
F_AUTH(){ F_LOG "$FUNCNAME: started"
    python2 $LAFPATH/auth.py
    F_LOG "$FUNCNAME: ended"
}; export -f F_AUTH

# check/ensure device is connected
F_CHKDEVCON(){ F_LOG "$FUNCNAME: started"
    # takes no argument
    F_AUTH
    python2 $LAFPATH/lglaf.py --skip-hello -c '!EXEC  uname -m\0' | tee -a $LOG
    RET=${PIPESTATUS[0]}
    if [ $RET -ne 0 ];then
        RES=$(F_MSG 700 "NO DEVICE CONNECTED?\nIf you have connected your device ensure that it is in DOWNLOAD mode\n(<u>not</u> fastboot, <u>not</u> recovery, <u>not</u> booted Android)" "--image=$SICONS/warning_64x64.png --button=Example-Picture:99 --button=Skip:0")
        F_LOG "$FUNCNAME: msge result = $RES"
        [ $RES -eq 99 ] && [ ! -z $SUDO_USER ] && sudo -u $SUDO_USER xdg-open "$SICONS/dlmode.png"
        [ $RES -eq 99 ] && [ -z $SUDO_USER ] && xdg-open "$SICONS/dlmode.png"
        RET=$RES
    else
        F_LOG "$FUNCNAME: Device seems to be connected!"
    fi
    F_LOG "RET: $RET"
    return $RET
}; export -f F_CHKDEVCON

# open a shell
F_SHELL(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    F_CHKDEVCON
    if [ $? -eq 0 ];then
        F_ELOG "device connected... Opening shell now!"
        xterm -e "cd $LAFPATH && echo -e '\n*****************\nTYPE the word exit TO CLOSE THIS WINDOW\n*********************\n\n'; python2 $LAFPATH/auth.py 2>&1 >> $LOG; python2 $LAFPATH/lglaf.py"
    fi
    F_LOG "$FUNCNAME: ended"
}; export -f F_SHELL

# start dialog for kdz extract
F_STARTKDZ(){ F_LOG "$FUNCNAME: started"
    # takes no arguments
    F_ELOG $FUNCNAME started

    EXCHOICES=$($FYAD --title="$YTITLE - EXTRACT" --width=800 --always-print-result --text \
        "\n  This will extract any KDZ file for you with just a click\n" \
        --form \
        --field="KDZ file":FL --file-filter="KDZ files (*.kdz)| *.kdz *.KDZ"\
        --field="Target directory\nHINT: Requires 32GB of free data":DIR \
        --field=:LBL \
        --field="Remove useless userdata partition (leave checked if unsure)":CHK \
        --field="Remove useless cache partition (leave checked if unsure)":CHK \
        undef /tmp true true true\
        )
    F_ELOG "returned: $EXCHOICES"
    KDZFILE=$(echo "$EXCHOICES" | cut -d '|' -f 1)
    TARGDIR=$(echo "$EXCHOICES" | cut -d '|' -f 2)
    UDATA=$(echo "$EXCHOICES" | cut -d '|' -f 4)
    KCACHE=$(echo "$EXCHOICES" | cut -d '|' -f 5)
    
    F_ELOG "KDZFILE = $KDZFILE, TARGDIR = $TARGDIR, UDATA = $UDATA, KCACHE = $KCACHE"

    [ ! -f "$KDZFILE" ] && F_ERR "EXTRACTKDZ" 3 "$KDZFILE does not exists or is not readable!"
    [ ! -z "$TARGDIR" ] && [ ! -d "$TARGDIR" ] && echo mkdir -p $TARGDIR

    F_EXTRACTKDZ "$KDZFILE" "$TARGDIR" $UDATA $KCACHE

    F_ELOG $FUNCNAME ended
};export -f F_STARTKDZ

# Update everything!
F_UPDATE(){ F_LOG "$FUNCNAME: started"
    # takes no arguments
    #

    # let the user switch between stable and develop
    AA=$($FYAD --title="$YTITLE - SETUP" --item-separator='|' --text "\n  Here you can choose between stable and development branches of SALT and its backends" --form \
            --field="  SALT branch\t":CBE "$BRSALT|$BROSALT" \
            --field="  kdztools branch\t":CBE "$BRKDZ|$BROKDZ" \
            --field="  lglaf branch\t":CBE "$BRLAF|$BROLAF"\
            --button=Update:0 --button=Cancel:1 \
         )

    [ $? -ne 0 ] && F_LOG "Aborted on user request" && F_EXIT

    BRSALT=$(echo "$AA"| cut -d "|" -f 1)
    BRKDZ=$(echo "$AA"| cut -d "|" -f 2)
    BRLAF=$(echo "$AA"| cut -d "|" -f 3)

    CNT=0
    for u in ${SALTPATH}:$BRSALT ${LAFPATH}:$BRLAF ${KDZTOOLS}:$BRKDZ; do 
        CNT=$((CNT+1))
        F_LOG "$FUNCNAME: updating ${u/:*} on branch ${u/*:} ..."
        echo "${CNT}:5"
        cd ${u/:*}
        echo "${CNT}:10"
        F_LOG "$($GIT checkout ${u/*:} 2>&1)"
        $GIT pull 2>&1 | tee -a $LOG | sed "s/^/${CNT}:#/g"
        test ${PIPESTATUS[0]} -eq 0 && echo "${CNT}:100"
    done | $FYAD --title="$YTITLE - UPDATING" --text="\n  <b>Be patient while SALT freshen up...</b>\n  (if a progress bar do NOT get to 100% a manual update is required)\n\n" --width 800 --multi-progress --bar="SALT codebase":norm --bar="LGLAF codebase":norm --bar="kdztools codebase":norm --button=Close
    F_LOG "$FUNCNAME: ended"
}; export -f F_UPDATE

# wipe a partition
F_WIPEPART(){ F_LOG "$FUNCNAME: started"
    # takes 2 arguments
    #
    # 1 => partition name to wipe
    # 2 => interactive (ia) or noninteractive (ni) mode. if not given we assume interactive!

    WPART="$1"
    ITP="$2"

    if [ "$ITP" == "ni" ];then 
        F_LOG "$FUNCNAME: wiping $WPART in noninteractive mode"
        python2 ${LAFPATH}/partitions.py --wipe $WPART 2>&1 | tee -a $LOG
    else
        F_LOG "$FUNCNAME: wiping $WPART in interactive mode"
        F_MSG 400 "Do you really want to wipe out <b>$WPART</b>?" "--button=Yes:0 --button='wtf NO never':1"
        [ $? -eq 0 ] && python2 ${LAFPATH}/partitions.py --wipe $WPART 2>&1 | tee -a $LOG | $FYAD --title="$YTITLE - WIPING" --width=800 --height=200 --text-info --listen --wrap --button=Close
    fi
    F_SYNC
}; export -f F_WIPEPART

# execute commands via lglaf
F_LAFEXEC(){ F_LOG "$FUNCNAME: started with these arguments: $@"
    # takes 1 argument

    EXECMD="$1"
    python2 ${LAFPATH}/lglaf.py --skip-hello -c "'!EXEC  ${EXECMD}\0'"
}; export -f F_LAFEXEC

# flush file system buffers
F_SYNC(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    F_LAFEXEC sync
}; export -f F_SYNC
